package tamagoshi.properties;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;

/**
 * Cette classe va permettre de récupérer et d'enregistrer des données de configuration via le fichier properties
 */

public class TamaConfiguration {

	/**
	 * Propriétés récupérées via le fichier et définies par l'application
	 */
	private Properties configuration;
	
	/**
	 * Chemin du fichier de propriétés
	 */
	private String location = "tamaGame.properties";
	
	/**
	 * Instance du singleton
	 */
	private static TamaConfiguration intsance;
	
	/**
	 * Methode issue du pattern Singleton pour avoir une instance unique
	 * @return L'instance unique de la classe
	 */
	public static synchronized TamaConfiguration getInstance() {
		if(TamaConfiguration.intsance == null) {
			TamaConfiguration.intsance = new TamaConfiguration();
		}
		return TamaConfiguration.intsance;
	}
	
	/**
	 * Initialise les propriétés
	 */
	private TamaConfiguration() {
		this.configuration=new Properties();
		if(existPropertyFiles()) {
			loadProperties();
		}
	}
	
	/**
	 * Modification de la difficulté du jeu
	 * @param difficulty Nouvelle difficulté
	 */
	public void setDifficulty(int difficulty) {
		int realValue = (difficulty>=1 && difficulty<=10) ? difficulty : 1;
		this.setProperty("difficulty", Integer.toString(realValue));
	}
	
	/**
	 * Récupère la difficulté du jeu
	 * @return La difficulté actuelle
	 */
	public int getDifficulty() {
		try {
			String difficulty = this.getProperty("difficulty");
			if(difficulty != null) {
				int difficultyValue = Integer.parseInt(difficulty);
				if(difficultyValue>=1 && difficultyValue<=10) {
					return difficultyValue;
				}
			}
		}
		catch(NumberFormatException e) {
			return 1;
		}
		return 1;
	}
	
	/**
	 * Modifie la méthode de selection des noms des tamagoshis
	 * @param value true si les noms sont autogénérés, false sinon
	 */
	public void setAutoGeneratedNamesSelection(boolean value) {
		this.setProperty("nameSelectionByUser", Boolean.toString(!value));
	}
	
	/**
	 * Récupère la méthode de selection des noms des tamagoshis
	 * @return true si les noms sont autogénérés, false sinon
	 */
	public boolean getAutoGeneratedNamesSelection() {
		return !getFreeNamesSelection();
	}
	
	/**
	 * Récupère la méthode de selection des noms des tamagoshis
	 * @return true si les noms ne sont pas autogénérés, false sinon
	 */
	private boolean getFreeNamesSelection() {
		String value = this.getProperty("nameSelectionByUser");
		if(value != null) {
			return Boolean.parseBoolean(value);
		}
		return false; 
	}
	
	/**
	 * Modifie la méthode de selection de la difficulté
	 * @param value true si la difficulty est fixée avant le lancement, false sinon
	 */
	public void setDifficultyFixed(boolean value) {
		this.setProperty("difficultySelectAtLaunch", Boolean.toString(!value));
	}
	
	/**
	 * Récupère la méthode de selection de la difficulté
	 * @return true si la difficulty est fixée avant le lancement, false sinon
	 */
	public boolean getDifficultyFixed() {
		return !getDifficultySelectAtLaunch();
	}
	
	/**
	 * Récupère la méthode de selection de la difficulté
	 * @return true si la difficulty est fixée pendant le lancement, false sinon
	 */
	private boolean getDifficultySelectAtLaunch() {
		String value = this.getProperty("difficultySelectAtLaunch");
		if(value != null) {
			return Boolean.parseBoolean(value);
		}
		return false; 
	}
	
	/**
	 * Récupère la liste des noms pour la génération aléatoire <br>
	 * Si rien n'est entré dans le fichier de configuration, des noms par défaut sont assignés automatiquement
	 * @return Un tableau de noms de tamagoshis
	 */
	public String[] getAutoGeneratedNames() {
		String lineName = this.getProperty("autoNames");
		if(lineName==null) {
			lineName = "Erwan,Bella,Malo,Niels,Laulau,Guillaume,Theo,Nico,Erwan,Eloise,Tom,Harry"; //Noms par defaut
			this.setProperty("autoNames", lineName);
		}
		return lineName.split(",");

	}
	
	/**
	 * Récupère la liste des 3 meilleurs scores pour un niveau de difficulté
	 * @param difficulty Niveau de difficulté dont on veut récupérer les scores
	 * @return Un tableau de 3 doubles, coreespondant aux trois meilleurs score (si il n'y en a pas, le score est remplacé par 0.0%)
	 */
	public double[] getScores(int difficulty) {
		double[] scores = new double[3];
		String[] scoresString;
		String lineValue = this.getProperty("scoreNiv"+difficulty);
		if(lineValue!=null) {
			int indexScore = 0;
			scoresString = lineValue.split(",");
			for(String score : scoresString) {
				scores[indexScore]=(Double.parseDouble(score));
				indexScore++;
			}
		}
		return scores;
	}
	
	/**
	 * Permet de sauvegarder un score pour un niveau de difficulté donné <br>
	 * Celui-ci ne sera enregsitré seuelement si il bas l'un des 3 meillurs pour ce niveau de difficulté
	 * @param difficulty Niveau de difficulté
	 * @param score Score à sauvegarder
	 * @return true si le score a été enregistré, false sinon
	 */
	public boolean saveScore(int difficulty,double score) {
		double[]scoreForDifficulty = getScores(difficulty);
		String lineScore="";
		boolean registered = false;
		for(double highscore : scoreForDifficulty) {
			if(!registered && (score>highscore)) {
				lineScore+=","+score;
				registered=true;
			}
			else {
				lineScore+=","+highscore;
			}
		}
		lineScore = lineScore.replaceFirst(",", "");
		setProperty("scoreNiv"+difficulty, lineScore);
		return registered;
	}
	
	/**
	 * Permet d'obtenir tous les languges gérés par l'application
	 * @return Une liste de Locale correspondants aux langages gérés par l'application
	 */
	public List<Locale> getManagedLanguages() {
		List<Locale>listLocales = new ArrayList<Locale>();
		String lineManagedLanguages = getProperty("managedLanguages");
		if(lineManagedLanguages==null) { //Premier lancement ou effacement de ligne
			lineManagedLanguages="fr,en";
			this.setProperty("managedLanguages", lineManagedLanguages);
		}
		for(String langue : lineManagedLanguages.split(",")) {
				Locale localToAdd = new Locale(langue);
				listLocales.add(localToAdd);
		}
		return listLocales;
	}
	
	/**
	 * Récupère le langage de "préférence" de l'utilisateur
	 * @return Une Locale correspondant au langage de préférence de l'utilisateur
	 */
	public Locale getUserLanugage() {
		Locale userLocale = null;
		String userLanguage = getProperty("userLanguage");
		if(userLanguage!=null) {
			userLocale = new Locale(userLanguage);
		}
		return userLocale;
	}
	
	/**
	 * Sauvegarde une locale comme langage de préférence de l'utilisateur
	 * @param locale Locale correspondant au langage selectionné par l'utilisateur
	 */
	public void setUserLanguage(Locale locale) {
		this.setProperty("userLanguage", locale.getLanguage());
	}
	
	/**
	 * Récupère une propriété sous forme de string
	 * @param key Nom de la propriété
	 * @return Un string correspondant à la valeur de la propriété ou null si elle n'existe pas
	 */
	private String getProperty(String key) {
		if(existProperty(key)) {
			return configuration.getProperty(key);
		}
		return null;
	}
	
	/**
	 * Défini une propriété
	 * @param key Nom dela propriété
	 * @param value Valeur de la propriété
	 */
	private void setProperty(String key,String value) {
		configuration.setProperty(key, value);
	}
	
	/**
	 * Sauvegarde toutes les propriétés dans un fichier properties
	 * @return true si la sauvegarde a pu être effectuée, false sinon
	 */
	public boolean storeProperties() {
		try {
			OutputStream out = new FileOutputStream(location);
			configuration.store(out, "Fichier des propriétés du jeu des tamagoshis");
		} catch (FileNotFoundException e) {
			return false;
		} catch (IOException e) {
			return false;
		}
		return true;
	}
	
	/**
	 * Permet de charger toutes les properiétés du fichier indiqué par {@link TamaConfiguration#location}
	 * @return true si le chargement a pu être effectué, false sinon
	 */
	private boolean loadProperties() {
		try {
			InputStream in = new FileInputStream(location);
			configuration.load(in);
		} catch (FileNotFoundException e) {
			return false;
		} catch (IOException e) {
			return false;
		}
		return true;
	}
	
	/**
	 * Permet de vérifier l'existance du fichier de propriétés
	 * @return true si le fichier existe, false sinon
	 */
	private boolean existPropertyFiles() {
		File propFile = new File(location);
		return propFile.exists();
	}
	
	/**
	 * Permet de vérifier l'existance d'une propriété donnée
	 * @param key Nom de la propriété dont on veut vérifier l'existance
	 * @return true si la propriété existe, false sinon
	 */
	private boolean existProperty(String key) {
		return configuration.getProperty(key) != null;
	}
	
}
